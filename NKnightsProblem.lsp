
(defun place-knights (lst)
	(if (isnKnightsInputValid lst)
		(outerrecurse 1 1 (caar lst) (cadar lst) nil (cadr lst))
		nil
	)
)

(defun isnKnightsInputValid (lst)
	(and (not (null lst)) (listp (car lst)) (= 2 (length (car lst))) (numberp (caar lst)) (numberp (cadar lst)) (listp (cadr lst)) (isnKnightsListInputValid (cadr lst)))
)

(defun isnKnightsListInputValid (lst)
	(or (null lst) (and (listp (car lst)) (= 2 (length (car lst))) (isnKnightsListInputValid (cdr lst))))
)

(defun outerrecurse (i j n m res lst)
	(let ((diagres nil))
		(setq diagres (recurseIntoSquares i j n m res lst))
		(recurse i j n m diagres lst)
	)
)

(defun recurse (i j n m res lst)
	(cond ((and (<= i n) (eql j m)) (recurse (1+ i) 1 n m (placeKnights i j n m res lst) lst))
		  ((and (<= i n) (not(eql j m))) (recurse i (1+ j) n m (placeKnights i j n m res lst) lst))
		  (T res)
	)
)

(defun recurseIntoSquares (i j n m res lst)
	(cond  ((or (< (- n i) 2) (< (- m j) 2) (= j m) (= i n)) res)
		   ((<= (- n i) (- m j)) (recurseIntoSquares i (+ j (- n i)) n m (addKnightsDiagonally i j (+ i (- n i)) (+ j (- n i)) res lst) lst))
		   (T (recurseIntoSquares (+ i (- m j)) j n m (addKnightsDiagonally i j (+ i (- m j)) (+ j (- m j)) res lst) lst))
	)
)

(defun addKnightsDiagonally (i j n m res lst)
	(let ((valuee nil))
		(if(>= (1+ (- n i)) 3)
			(setq valuee (place3x3 i j (+ 2 i) (+ 2 j) res lst))
			nil
		)
		(recurseplacenally (+ 3 i) j n m valuee lst i)
	)
)

(defun recurseplacenally (i j n m res lst ki)
	(if (> i n)
		res
		(recurseplacenally (1+ i) j n m (placexnally i j n m res lst ki) lst ki)
	)
)

(defun placexnally (i j n m res lst ki)
	(let ((valuee nil))
		(if (and (not (lisMember (list i j) lst)) (not (lisMember (list i j) res)) (lisSafe i j n m res))
			(setq valuee (cons (list i j) res))
			(setq valuee res)
		)
		(if (= i ki)
			valuee
			(placexnally (1- i) (1+ j) n m valuee lst ki)
		)
	)
)

(defun place3x3 (i j n m res lst)
	(let ((valuee nil))
		(if (and (not (lisMember (list i j) lst)) (not (lisMember (list i j) res)) (lisSafe i j n m res))
			(setq valuee (cons (list i j) res))
			(setq valuee res)
		)
		(if (and (not (lisMember (list (1+ i) (1+ j)) lst)) (not (lisMember (list (1+ i) (1+ j)) res)) (lisSafe (1+ i) (1+ j) n m res))
			(setq valuee (cons (list (1+ i) (1+ j)) valuee))
			(setq valuee valuee)
		)
		(if (and (not (lisMember (list (+ 2 i) (+ 2 j)) lst)) (not (lisMember (list (+ 2 i) (+ 2 j)) res)) (lisSafe (+ 2 i) (+ 2 j) n m res))
			(setq valuee (cons (list (+ 2 i) (+ 2 j)) valuee))
			(setq valuee valuee)
		)
		(if (and (not (lisMember (list i (+ 2 j)) lst)) (not (lisMember (list i (+ 2 j)) res)) (lisSafe i (+ 2 j) n m res))
			(setq valuee (cons (list i (+ 2 j)) valuee))
			(setq valuee valuee)
		)
		(if (and (not (lisMember (list (+ 2 i) j) lst)) (not (lisMember (list (+ 2 i) j) res)) (lisSafe (+ 2 i) j n m res))
			(cons (list (+ 2 i) j) valuee)
			valuee
		)
	)
)

(defun placeKnights (x y n m res lst)
	(let ((valuee nil))
		(if (and (not (lisMember (list x y) lst)) (not (lisMember (list x y) res)) (lisSafe x y n m res))
			(setq valuee (cons (list x y) res))
			(setq valuee res)
		)
		(if (and (>= x 3) (<= y (1- m)) (not (lisMember (list (- x 2) (1+ y)) lst)) (not (lisMember (list (- x 2) (1+ y)) valuee)) (lisSafe (- x 2) (1+ y) n m valuee))
			(setq valuee (cons (list (- x 2) (1+ y)) valuee))
			(setq valuee valuee)
		)
		(if (and (>= x 3) (>= y 2) (not (lisMember (list (- x 2) (1- y)) lst)) (not (lisMember (list (- x 2) (1- y)) valuee)) (lisSafe (- x 2) (1- y) n m valuee))
			(setq valuee (cons (list (- x 2) (1- y)) valuee))
			(setq valuee valuee)
		)
		(if (and (>= x 2) (<= y (- m 2)) (not (lisMember (list (1- x) (+ y 2)) lst)) (not (lisMember (list (1- x) (+ y 2)) valuee)) (lisSafe (1- x) (+ y 2) n m valuee))
			(setq valuee(cons (list (1- x) (+ y 2)) valuee))
			(setq valuee valuee)
		)
		(if (and (>= x 2) (>= y 3) (not (lisMember (list (1- x) (- y 2)) lst)) (not (lisMember (list (1- x) (- y 2)) valuee)) (lisSafe (1- x) (- y 2) n m valuee))
			(setq valuee(cons (list (1- x) (- y 2)) valuee))
			(setq valuee valuee)
		)
		(if (and (<= x (1- n)) (<= y (- m 2)) (not (lisMember (list (1+ x) (+ y 2)) lst)) (not (lisMember (list (1+ x) (+ y 2)) valuee)) (lisSafe (1+ x) (+ y 2) n m valuee))
			(setq valuee(cons (list (1+ x) (+ y 2)) valuee))
			(setq valuee valuee)
		)
		(if (and (<= x (1- n)) (>= y 3) (not (lisMember (list (1+ x) (- y 2)) lst)) (not (lisMember (list (1+ x) (- y 2)) valuee)) (lisSafe (1+ x) (- y 2) n m valuee))
			(setq valuee(cons (list (1+ x) (- y 2)) valuee))
			(setq valuee valuee)
		)
		(if (and (<= x (- n 2)) (<= y (1- m)) (not (lisMember (list (+ x 2) (1+ y)) lst)) (not (lisMember (list (+ x 2) (1+ y)) valuee)) (lisSafe (+ x 2) (1+ y) n m valuee))
			(setq valuee(cons (list (+ x 2) (1+ y)) valuee))
			(setq valuee valuee)
		)
		(if (and (<= x (- n 2)) (>= y 2) (not (lisMember (list (+ x 2) (1- y)) lst)) (not (lisMember (list (+ x 2) (1- y)) valuee)) (lisSafe (+ x 2) (1- y) n m valuee))
			(cons (list (+ x 2) (1- y)) valuee)
			 valuee
		)
		
	)
)

;Using equal because two lists are being compared
(defun lisMember (mem lst)
	(if (null lst)
		nil
		(or (equal mem (car lst)) (lismember mem (cdr lst)))
	)
)
;Using equal because two lists are being compared
(defun lisMemx (x y n m lst)
	(let ((mem (list x y)))
		(cond ((null lst) nil)
			  ((and (>= x 1) (<= x n) (>= y 1) (<= y m)) (or (equal mem (car lst)) (lisMemx x y n m (cdr lst))))
			  (T nil)
		)
	)
)

(defun lisSafe (x y n m reslst)
	(not (or (lisMemx (- x 2) (1+ y ) n m reslst) (lisMemx (- x 2) (1- y) n m reslst) (lisMemx (1- x) (+ y 2) n m reslst) (lisMemx (1- x) (- y 2) n m reslst) (lisMemx (1+ x) (+ y 2) n m reslst) (lisMemx (1+ x) (- y 2) n m reslst) (lisMemx (+ x 2) (1+ y) n m reslst) (lisMemx (+ x 2) (1- y) n m reslst)))
)